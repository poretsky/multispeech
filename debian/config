#!/usr/bin/perl -w
# debconf config script for multispeech
#
# synopsis
#    config  configure  <installed-version>
#    config  reconfigure  <installed-version>
#
# 
# ----  Configuring a speech server using debconf  ----
# 
# A package can contribute several speech servers, as follows.
# 
# 
# Use the method described in debconf-devel(7) "choosing among related
# packages" to detect a new package.  All packages installing speech
# servers include the same template file.  A fake question
# "shared/emacspeak/fake" is shared by all the packages.  Each package
# contributes its name as a "choice".  The question is "fake" because
# the it is never displayed to a user.  Instead, if the package list
# changes, use fset to declare a *different* question as not seen:
# "shared/emacspeak/device".  That question has the real speech server
# choices.  A new package contributes all the relevant choices to all
# questions, and a package being removed removes its choices (in
# prerm).

use strict;

use Debconf::Client::ConfModule q(:all);

die "Syntax error: no argument" if ($#ARGV < 0);
my $id;
my $action=$ARGV[0];
my $installed_version=$ARGV[1];
my $ret;
my $database;
my $owners;
my $choices;
#open LOG,    ">> /var/log/emacspeak"  or die "can't open logfile:  $!";

($ret, $owners)=metaget('shared/emacspeak/fake','owners');
($ret, $choices)=metaget('shared/emacspeak/fake','choices');
if ($owners ne $choices){
    subst('shared/emacspeak/fake','choices',$owners);
    # the devices have changed, so ask which device to use
    fset('shared/emacspeak/device', 'seen', 'false');
}

# combine speech server choices from:
# - previously installed packages (i.e. their .blurb files)
# - this package (even though our .blurb files have not been unpacked)
# - other packages being installed at this time (their .blurb files
#   have not been unpacked either, but they may have registered their
#   choices with debconf)

# get choices already in the debconf database
my ($b, $p, $t, $device, $olddevice, 
    %blurb, %program, %tcl, %device, %db, $devicelist);
($ret, $database) = metaget ('shared/emacspeak/database', 'choices');
foreach (split (/, */, $database)){ # debconf database is comma separated
    ($b, $p, $t, $device)=split(/:/);
    # load data into hashes
    $blurb{$device}=$b;
    $program{$device}=$p;
    $tcl{$device}=$t;
    $db{$device}="$b:$p:$t";	# local database is colon separated
}

# Add choices from unpacked .blurb files from other packages, in case
# their config scripts haven't run yet (or they aren't debconf configured)
my $dirname='/usr/share/emacs/site-lisp/emacspeak/blurbs';
if (opendir(DIR,$dirname)){
    my @fnames=readdir(DIR);
    closedir(DIR);
    foreach (@fnames){
	if (/.blurb$/){
	    open(IF,"$dirname/$_");
	    while(<IF>){
		if (/^blurb: *(.*)$/) {$b=$1;}
		if (/^program: *(.*)$/) {$p=$1;}
		if (/^tcl: *(.*)$/) {$t=$1;}
		if (/^device: *(.*)$/) {$device=$1;}
	    }
	    $blurb{$device}=$b;
	    $program{$device}=$p;
	    $tcl{$device}=$t;
	    $db{$device}="$b:$p:$t";
	}
    }
}

# Add choices in this package, using "device" as the key.
# E.g. this .blurb file:
#   blurb: Software DECtalk
#   program: dtk-soft
#   tcl: tcl
#   device: sound card with Software DECtalk
# would generate this entry:
#   $db{"sound card with Software DECtalk"}="Software DECtalk:dtk-soft:tcl";

# These entries must be updated whenever .blurb files are changed.

# FIXME these entries should be inserted here automatically at package
# build time, based on the .blurb files.  (This cannot be done during
# installation, because this package's .blurb files are not unpacked
# at config time.)

$db{"Multispeech"}="Multispeech:multispeech:";

my $newdatabase='';
foreach $device (sort keys %db) {
    ($b,$p,$t)=split(':',$db{$device});
    $newdatabase .= "$b:$p:$t:$device, ";
}
if ($database ne $newdatabase){
    # update debconf database
    subst ('shared/emacspeak/database', 'choices', $newdatabase);
    my $devicelist=join(', ', sort keys %db);
    subst ('shared/emacspeak/device', 'choices', $devicelist);
}
